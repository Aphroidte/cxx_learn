# Why Adopt Abseil

<!-- TOC -->

- [Why Adopt Abseil](#why-adopt-abseil)
  - [1. 为什么要使用Abseil库](#1-为什么要使用abseil库)
  - [2. 兼容当前和未来的c++标准](#2-兼容当前和未来的c标准)
  - [3. 兼容谷歌OSS项目](#3-兼容谷歌oss项目)
  - [4. 升级支持](#4-升级支持)
  - [5. 生产经验](#5-生产经验)
  - [6. 与标准不同的设计优先级](#6-与标准不同的设计优先级)
  - [7. 总结](#7-总结)

<!-- /TOC -->

## 1. 为什么要使用Abseil库

> 原文地址：[Why Adopt Abseil?](https://abseil.io/about/philosophy#why-adopt-abseil)
>
> [C++ Developer Guide](https://abseil.io/docs/cpp/)

或者为什么世界上还有另一个c++实用程序库集合的空间？

当你开始一个新的c++项目时，有几个主要的原因，我们推荐Abseil作为你的首选工具代码:

- 兼容当前和未来的c++标准，并计划随时间的发展而发展
- 与谷歌 OSS 项目的兼容性——这些是协议缓冲区、gRPC和TensorFlow的基本类型
- 升级支持——使项目易于工作在最新的版本 (make it easy to *live at head*)
- 生产经验——这些是我们在谷歌生产中使用的接口
- 对与c++标准不同的设计优先级集合感兴趣

这些论点在多大程度上适用于你的项目取决于很多东西:我们不认为 *Abseil* 是一颗银弹，或者是每个人的问题的完美解决方案。另一方面，这些库在谷歌中已经成长了很多年，我们在它们的演变中已经了解了很多。 我们知道，这些库和我们的升级策略可以很好地解决行业中某些类型的重要问题，随着时间的推移，我们已经学会了如何以一种不断发展但可维护的方式提供这类基础设施。

## 2. 兼容当前和未来的c++标准

谷歌已经开发了许多 abstractions，这些 abstractions 与 c++ 14、c++ 17 以及更多版本中所包含的特性相匹配或紧密匹配。使用这些 abstractions 的 *Abseil* 版本允许您现在访问这些特性，即使您的代码还没有准备好在c++ 11之后的世界中使用。

以 c++ 17 的 `std::string_view` 为例: 该类型的标准化主要是基于谷歌使用内部类型 `StringPiece` 的经验。我们在内部做了大量的工作，使 `StringPiece` 类型具有与 `string_view` 相同的 *API*，现在我们用 *Abseil* 发布它——不是用 `std::string_view`，而是用 `absl::string_view`。

**我们为什么要这么做? 这不是意味着现在有两种几乎相同的类型吗? 这不会引起混乱吗?**

我们不这么认为: 如果你看一下 `string_view.h` 中的预处理条件结构，你会发现我们试图识别你的 c++ 是否支持 `std::string_view`；如果支持，`absl::string_view` 将仅定义为标准类型的别名；如果没有，则会得到兼容 c++ 11/ c++ 14 的类型实现。这意味着您可以采用 *Abseil*，对于我们“预发布”的类型，您可以使用来自 `abls` 命名空间的类型。只要您的项目使用适当的编译器/标准库版本构建，我们就不再关注它，只留给您标准类型，尽管拼写很滑稽。

更好的做法是: 一旦你知道你的项目只会用合适的语言版本来构建，你就可以运行我们提供的工具来将引用`absl::string_view` 的地方更改为 `std::string_view`——因为它们是相同的类型，这是安全的，即使跨越API边界。

因此，您可能想采用Abseil的一个原因是: 尽早访问即将发布的 c++ 标准库版本的功能，并具有明确的迁移路径。

## 3. 兼容谷歌OSS项目

多年来，谷歌对与其他代码库和OSS项目兼容的需求已经发生了变化。十年前，我们的大部分代码都是内部的，我们偶尔会开源一些我们认为很酷的东西。如今，情况有所不同: 我们希望 Protocol Buffers 和 gRPC 成为健康的独立项目。这些api 是谷歌云产品的入口点——结合我们的观点，云供应商在客户不被锁定的情况下功能最好，我们希望这些入口点是开放的和可持续的。也就是说，这些项目最初的c++版本来自于一个使用了某些习惯用法和api的代码库，而没有一个很好的支持这些api的OSS版本供这些项目依赖，这是摩擦的来源。

如果你大量使用谷歌 Cloud 或其他谷歌 OSS 项目，采用 *Abseil* 应该是一个明显的胜利:无论如何，这些库将成为你依赖链的一部分，并将越来越多地出现在你与之交互的 api 中。

## 4. 升级支持

我们建议您选择 *Live at Head*：

我们已经公开谈论过谷歌的内部代码库，以及我们在代码增长时保持代码可维护性的努力。用 250M 行 c++ 代码和几乎每一个从头构建的项目，我们展示了一种不同的软件工程方法:一种基本上不存在版本不匹配问题的方法，一种即使是最常见的库也可以定期、安全地重构的方法。通过Abseil，我们的目标是将一些经验带到开源世界。

为此，我们作出以下承诺：

- 如果你的代码按照我们的兼容性准则运行，它就不应该在我们的更改面前崩溃。
- 如果我们需要重构一个您所依赖的API，我们将提供一个工具，该工具应该能够对表现良好的代码执行重构。

作为交换，我们想知道你怎么调用我们，我们想让你 *Live at Head*。

我们相信当前的软件范式在本质上是不可持续的:依赖关系管理非常复杂。无法解决的 “钻石依赖（diamond dependency）” 问题是常见的——避免这些问题的唯一方法是永远不更改，或者确保没有多个版本。我们更喜欢后者，所以我们将尽我们所能让您与我们一起生活——如果一切都是从源头开始构建的，那么就不会有更多的钻石依赖、分支冲突和关于合并策略的复杂讨论。所有这些时间都可以花在更有用的事情上，比如实际编写代码和为用户解决问题。加入 Abseil，停止支付内容管理税!

如果你选择 *Not Live at Head*：

- 当然，您可以自由地派生 Abseil，将其包含在您的项目中，并以任何方便您的开发实践的方式管理依赖关系。
- 我们会定期将一个标签标记为“受支持”并进行分支——如果我们发现安全问题或主要性能问题，我们会更新这些分支。我们的期望是每6个月做一次，并支持这些分支2年。

## 5. 生产经验

我们将要发布的库具有一个谱系:在谷歌的生产环境中使用这些api的多年经验。我们已经了解了什么可行，什么不可行，什么设计会导致bug、性能问题和误用。长期以来，我们一直试图保持设计的简单——不支持没有强烈动机的功能，因为每一个额外的功能都有维护成本，并对未来的更改施加了约束。您在这里看到的是我们发现的简单性和满足生产使用需求以及不断发展的代码库之间的良好平衡。

例如，当我们发布更新的命令行标志API时，我们将包含一个新特性——退役的标志。这些标志可以被解析器识别，但会被忽略(并且根据命令行标志代码无法访问)。就其本身而言，该功能可能对大多数用户没有意义。然而，在一个庞大的共享代码库中，多个产品在不同的时间使用不同的作业配置来删除发布版本，一旦某个标志已经不再有用，就很难删除它。退役旗帜的设计目的是提供一个临时桥梁，以便在不破坏构建或生产部署的情况下缓慢地推出更改。Abseil 充满了这些小特性，使它成为一组非常适合支持实际生产问题的实用程序库。

## 6. 与标准不同的设计优先级

c++ 标准有两个首要目标:

- 你不会(在运行时)为自己不使用的东西付费
- 标准 API 应该适用于任何领域(它通常不涉及平台或问题领域)。

这些都是很好的目标，对于像标准库这样的东西来说非常合理。也就是说，这些并不是唯一合理的目标——相反，我们可以决定为最常见的用例提供优秀的支持，而对不常见的用例提供很少或不支持。

例如，取我们的 `absl::Time` 和 `absl::Duration` 类型。它们在概念上等价于 `std::chrono::time_point` 和 `std::chrono::duration`，实际上这两种类型是相互转换的。然而，该标准要求在几十亿年的时间内支持32位全秒到128位纳秒分辨率的域内可用，因此std::chrono抽象不是类型，而是类模板。好的一面是，无论您是在嵌入式设备上进行物理模拟还是正常运行时间跟踪，这样的通用定义都是好的。不好的一面是，使用std::chrono的代码往往模板过多且冗长。

Abseil尝试了一种不同的方法:我们选择了一种合理优化的表示，并在数千年的时间里仍然提供了有用的亚纳秒(非浮点)分辨率:显然，这种分辨率在某些领域无法工作，但对于广泛的任务，我们可以对具体类型进行操作，并使用更简单的(非模板)代码。或者，在可用性光谱的另一端:在一个积分秒粒度就足够的领域，标准不敢强迫用户使用更细的粒度类型——你不应该为你不使用的东西付费。我们发现，与时间编程错误的成本相比，cpu限制的时间处理代码无法使用96或128位的时间表示的可能性非常小。

如果您的用例是“正常的”(或者至少，与我们所发现的正常一致)，Abseil 可能会提供一个有用的对应 c++ 标准所选择的设计。当我们提出一些与标准冲突的内容时，我们将清楚为什么我们会产生分歧，并尽最大努力保持互操作性。

## 7. 总结

我们明确地衡量进度的优先级，仔细的API设计，对我们发现的共同需求的优先级，以及随着时间的推移的兼容性——这些不是每个项目都应该优化的目标。如果你的项目只有一年的寿命，你可能会找到一个很酷的新项目，只发布一个版本，但不升级它。然而，如果您发现自己在一个 c++ 11 项目中，期待着 c++ 17 或更高的版本，或者您使用 protobufs 或 gRPC，那么 Abseil 可能会很好地为您服务。或者，您可能不太关心您使用的实用程序库，但是对我们的 “live at head” 方法很感兴趣。或者您知道您的平台和用例是良好定义的，并且希望比标准提供的设计稍微宽容一些。

不管Abseil的有趣之处是什么，我们都很高兴你能看一看。阅读我们的政策和兼容性指南。注册我们的社区邮件列表。把我们的库带出去转一转——像 `StrCat` 和 `StrSplit` 这样的小玩意放在手边会让人惊喜不已。如果您还没有看到任何有趣的东西，请耐心等待:这只是使我们最常见的实用程序库可移植和可用的持续过程的开始。
