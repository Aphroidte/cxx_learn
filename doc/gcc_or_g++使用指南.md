# gcc/g++ 使用指南

<!-- TOC -->

- [gcc/g++ 使用指南](#gccg-使用指南)
  - [1. 常用编译选项](#1-常用编译选项)
    - [1.1. 编译生成动态库](#11-编译生成动态库)
      - [1.1.1. fPIC](#111-fpic)

<!-- /TOC -->

## 1. 常用编译选项

### 1.1. 编译生成动态库

#### 1.1.1. fPIC

`-fPIC` 作用于编译阶段，告诉编译器产生与位置无关的代码（Position Independent Code）。

> 位置无关的代码（Position Independent Code）：这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针（如 IA32 的 EIP 寄存器）的值，加上一个偏移得到全局变量/函数的地址。（使用 `-fPIC` 的 Linux 动态库）
>
> 可重定位代码（Relocatable Code）：生成动态库时假定它被加载在地址 0 处。加载时它会被加载到一个地址（base），这时要进行一次重定位（relocation），把代码、数据段中所有的地址加上这个 base 的值。这样代码运行时就能使用正确的地址了。。（Windows DLL 以及不适用 -fPIC 的 Linux 动态库）

- `-fPIC` 的优点：
  1. 加载速度快，因为不需要重定位
  2. 多个进程引用同一个动态库时，可以共用内存。这一个库在不同进程中的虚拟地址不同，但操作系统显然会把它们映射到同一块物理内存上。对于可重定位代码，则必须为每个库都在物理内存中复制一份副本，因为需要修改其中的地址。（当然，主流现代操作系统都启用了分页内存机制，这使得重定位时可以使用 *COW（copy on write）* 来节省内存（32 位 Windows 就是这样做的）；然而，页面的粒度还是比较大的（例如 IA32 上是 4KiB），至少对于代码段来说能节省的相当有限。）
- `-fPIC` 的缺点：影响代码执行效率。因为一般要用到 *GOT（global offset table）* 来定位全局变量和函数。这样导致代码的效率略低。

> 注1：**对于 AMD64，由于 AMD64 实现了 [RIP+constant] 的寻址方式，所以不存在上述的缺点**
>
> 注：位置无关的代码需要特殊的支持，因此只能在某些机器上工作。

---

`-fpic` 与 `-fPIC` 的区别：

它们都是为了在编译时产生与位置无关的代码。`-fpic` 为了节约内存，在 GOT 里面预留了“短”长度。而 `-fPIC` 则采用了更大的跳转项。

采用 `-fpic` 编译，如果链接的可执行文件的 GOT 大小超过了机器特定的最大大小，你会从链接器得到一个错误消息，表明 `-fpic` 不工作；在这种情况下，用 `-fPIC` 重新编译。

---

满足以下情况，建议不采用 `-fPIC` 进行编译：

1. 该库可能需要经常更新
2. 该库需要非常高的效率（尤其是使用了很多全局函数/变量）
3. 该库并不是很大
4. 该库基本不需要被多个应用程序共享
